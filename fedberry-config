#!/bin/bash -
# Copyright (C) 2018, Vaughan Agrez <devel@agrez.net>
# fedberry-config is released under GPL licence (version 3)
# See LICENSE file for copyright and license details


###
# VARIABLE_DEFINITIONS
###

### Software
NAME=fedberry-config
AUTHORS="Vaughan Agrez"
YEAR=2018
VERSION=0.4.7
BUG_REPORTS="https://github.com/fedberry/fedberry-config"


### System config dirs & files
BOOT_DIR=/boot
CFG_TXT=$BOOT_DIR/config.txt
CMD_TXT=$BOOT_DIR/cmdline.txt
DTO_DIR=$BOOT_DIR/overlays
MODULES_DIR=/usr/lib/modules
SE_CFG=/etc/selinux/config
OS_RELEASE=/etc/os-release
LOG_FILE=/var/log/$NAME.log


### OS environment / hardware
ARCH=$(arch| sed -r 's/([6-7])l/\1hl/')
OS_NAME=$(awk -F= '/^NAME=/ { print $2 }' $OS_RELEASE)
OS_VER_ID=$(awk -F= '/^VERSION_ID/ { print $2 }' $OS_RELEASE)
RPI_MODEL=$( </sys/firmware/devicetree/base/model tr -d '\0')
BOARD_REV=$(awk '/Revision/ { print $3 }' /proc/cpuinfo)


### Misc standard messages / args
TXT_ENB="is currently ENABLED.\n\nDo you want to DISABLE it?"
TXT_DIS="is currently DISABLED.\n\nDo you want to ENABLE it?"
MENU_ARGS="MENU_TITLES MENU_BUTTONS MENU_ITEMS MENU_ACTIONS"
TXT_GPU_MEM="MB of system memory has been allocated to the GPU.
\n\nA reboot is required for the change in GPU memory allocation."
TXT_RBN="A reboot is required for changes to take affect.
\n\nDo you want to reboot now?"


# Exclude some DTO's from the cmdline
DTO_EXCLUDE=(vc4-kms-v3d vc4-fkms-v3d start_x)


### Default DTP & config opt values
declare -A DEF_VALS=(
    [gpu_mem]=32
    [start_x]=0
    [i2c]=on
    [i2s]=on
    [spi]=on
    [audio]=on
    [disable_splash]=1
    [act_led_trigger]=none
    [act_led_activelow]=off
    [pwr_led_trigger]=none
    [pwr_led_activelow]=off
    )


### Name references for various DTOs, DTPs & config options
declare -A REF_NAMES=(
    [act_led_activelow]="Activity (Green) LED"
    [allo-boss-dac-pcm512x-audio]="Allo Boss DAC audio card support"
    [allo-digione]="Allo Digione audio card support"
    [audio]="Onboard alsa audio interface"
    [disable_splash]="Initial rainbow boot splash"
    [fe-pi-audio]="Fe-Pi Audio sound card support"
    [googlevoicehat-soundcard]="Google Voice HAT sound card support"
    [hifiberry-amp]="HifiBerry Amp & Amp+ audio card support"
    [hifiberry-dac]="HifiBerry DAC audio card support"
    [hifiberry-dacplus]="HifiBerry DAC+ audio card support"
    [hifiberry-digi]="HifiBerry Digi & Digi+ audio card support"
    [hifiberry-digi-pro]="HifiBerry Digi+ Pro audio card support"
    [iqaudio-dac]="IQaudio DAC audio card support"
    [iqaudio-dacplus]="IQaudio DAC+ audio card support"
    [iqaudio-digi-wm8804-audio]="IQAudIO Digi WM8804 audio card support"
    [justboom-dac]="JustBoom DAC/Amp HAT & DAC/Amp Zero audio card support"
    [justboom-digi]="JustBoom Digi HAT and Digi Zero audio card support"
    [i2c]="I2C interface"
    [i2c-rtc]="I2C RTC support"
    [i2s]="I2S interface"
    [lirc-rpi]="RPi LIRC support"
    [pi3-disable-wifi]="RPi3 onboard WiFi"
    [pwr_led_activelow]="Power (Red) LED"
    [spi]="SPI interface"
    [start_x]="RPi Camera"
    [vc4-fkms-v3d]="VC4 Mesa/Dispmanx"
    [vc4-kms-v3d]="VC4 Mesa"
    )


### Board manufacturing information
declare -A MFG_INFO=(
    [a01040]="Sony, UK"
    [a01041]="Sony, UK"
    [a21041]="Embest, China"
    [a22042]="Embest, China"
    [a02082]="Sony, UK"
    [a22082]="Embest, China"
    [a32082]="Sony, Japan"
    [a020d3]="Sony, UK"
    [9020e0]="Sony, UK"
    )


###
# FUNCTION_DEFINITIONS
###

log_init()
{
    [ -f $LOG_FILE ] && mv $LOG_FILE $LOG_FILE.old || touch $LOG_FILE
    echo -e "\n##### $NAME - $VERSION - LOG #####" &>$FDSC
    NO_DIALOG=1 show_info &>>$FDSC; NO_DIALOG=0
    echo -e "\n" &>>$FDSC
}


dbg_chk()
{
    if [ $DEBUG -eq 1 ]; then
        if [[ $LOG -eq 1 ]]; then
            FDSC=$LOG_FILE
            log_init
        else
            FDSC=/dev/fd/1
        fi
    else
        FDSC=/dev/null
    fi
}


msg()
{
    if [[ $NO_DIALOG -ne 1 ]]; then
        if [ -z "$2" ]; then
            whiptail --msgbox "$1" 20 60
        else
            whiptail --msgbox --title "$1" "$2" 20 60
        fi
        [ $DEBUG == 1 ] && echo -e "$1\n$2" &>>$FDSC
    else
        echo -e "$1\n\n$2"
    fi
}


yes_no()
{
    [ $DEBUG == 1 ] && echo -e "$1\n$2"  &>>$FDSC

    if [ -z "$2" ]; then
        whiptail --yesno "$1" 20 60
    else
        whiptail --yesno --title "$1" "$2" 20 60
    fi
}


ask_reboot()
{
    # If needed, offer a reboot
    if [[ $SGST_REBOOT -eq 1 ]]; then
        if [ -z "$1" ]; then
            yes_no "Reboot Required" "$TXT_RBN"
        else
            yes_no "Reboot Required" "$1\n\nDo you want to reboot now?"
        fi

        if [ $? == 0 ]; then
            sync
            setsid sleep 5 && systemctl reboot &
            msg "System will reboot in 5 secs"
            exit 0
        fi
    fi
}


dialog_menu()
{
    while true; do
        local -n TITLE=$1
        local -n BUTTONS=$2
        local -n ITEMS=$3
        local -n ACTIONS=$4

        DLG_CMD=(whiptail \
        --title "${TITLE[0]}" \
        --menu "${TITLE[1]}" \
        --backtitle "$OS_NAME $OS_VER_ID ($ARCH)" \
        --ok-button "${BUTTONS[0]}" \
        --cancel-button "${BUTTONS[1]}" $DLG_H $DLG_W $DLG_MH)

        SEL=$("${DLG_CMD[@]}" "${ITEMS[@]}" 3>&1 1>&2 2>&3)
        RETVAL=$?

        if [ $DEBUG == 1 ]; then
            echo -e "Menu: ${TITLE[0]}\nItems: ${ITEMS[@]}\nActions: ${ACTIONS[@]}" &>>$FDSC
            if [ $RETVAL == 0 ]; then
                echo -e "Selection:${ACTIONS[$SEL]}\n" &>>$FDSC
            else
                echo -e "No selection\n" &>>$FDSC
            fi
        fi

        case $RETVAL in
            0) eval ${ACTIONS[$SEL]} ;;
            1) break ;;
            255) echo "Esc Pressed" ;;
        esac
    done
}


dialog_prog()
{
    whiptail --gauge "$1" 10 70 0
}


dialog_size()
{
    DLG_H=17
    DLG_MH=$(($DLG_H-9))
    DLG_W=$(tput cols)

    if [ -z "$DLG_W" -a "$DLG_W" -lt 60 ]; then
        DLG_W=80
    elif [ "$DLG_W" -gt 178 ]; then
        DLG_W=120
    fi
}


dtree_enable()
{
    # Force enabling of Device Tree support
    if [[ $(grep -cim1 ^device_tree= $CFG_TXT) -eq 1 ]]; then
        # remember, its the opposite!
        cfg_disable device_tree
    fi
}


dto_probe()
{
    # Define the DTO variables
    DTO="dtoverlay=$1"
    DTB="$1-overlay.dtb"
    DTBO="$1.dtbo"

    # Test config.txt for DTO
    DTO_ENABLED=$(grep -cim1 ^$DTO $CFG_TXT)
    DTO_DISABLED=$(grep -cim1 "^# *$DTO" $CFG_TXT)
}


dto_enable()
{
    dto_probe $1

    if [ ! -f $DTO_DIR/$DTB ] && [ ! -f $DTO_DIR/$DTBO ]; then
        echo "ERROR:" "can't find $DTO or $DTBO in current kernel"
        return 0
    fi

    if [ $DTO_DISABLED -eq 1 ]; then
        dto_write enable $1
        SGST_REBOOT=1
    elif [ $DTO_ENABLED -ne 1 ]; then
        dto_write add $1
        SGST_REBOOT=1
    fi
}


dto_disable()
{
    dto_probe $1
    if [ $DTO_ENABLED -eq 1 ]; then
        dto_write disable $1
        SGST_REBOOT=1
    fi
}


dto_write()
{
    if [ $1 == "enable" ]; then
        dtree_enable
        sed -i "s/^# *$DTO/$DTO/" $CFG_TXT
        dyn_dto_add $2
    elif [ $1 == "add" ]; then
        dtree_enable
        echo -e "$DTO" >> $CFG_TXT
        dyn_dto_add $2
    elif [ $1 == "disable" ]; then
        sed -i "s/^$DTO/#$DTO/" $CFG_TXT
        dyn_dto_rem $2
    fi
}


dto_prm_update()
{
    # 1st arg = DTO name; 2nd arg = new parameter; 3rd arg = new value
    if [ "$3" != "" ]; then
        sed -i "s/^dtoverlay=$1.*$/dtoverlay=$1,$2=$3/" $CFG_TXT
    elif [ "$3" == "" ] && [ "$2" != "" ]; then
        sed -i "s/^dtoverlay=$1.*$/dtoverlay=$1,$2/" $CFG_TXT
        dyn_dto_add $1 $2
    elif [ "$2" == "" ] && [ "$1" != "" ]; then
        dyn_dto_add $1
    fi
}


dto_ask()
{
    # reset for each selection
    BAILED=0
    DRV_DISABLED=0

    # hackity hack! sometimes overlays work backwards :-/
    if [[ "$@" =~ "--reverse" ]]; then
        MSG_DIS=$TXT_ENB
        MSG_ENB=$TXT_DIS
    else
        MSG_DIS=$TXT_DIS
        MSG_ENB=$TXT_ENB
    fi

    # test config.txt for DTO references
    dto_probe $1

    if [ ! -f $DTO_DIR/$DTB ] && [ ! -f $DTO_DIR/$DTBO ]; then
        msg "ERROR:" "can't find $DTO or $DTBO in current kernel"
        NO_OVERLAY=1
    else
        if [ $DTO_ENABLED -eq 1 ]; then
            # DTO is enabled already
            yes_no "${REF_NAMES[$1]} $MSG_ENB"
            if [ $? -eq 0 ]; then
                SGST_REBOOT=1
                DRV_DISABLED=1
                dto_write disable $1
            else
                BAILED=1
            fi
        elif [ $DTO_DISABLED -eq 1 ]; then
            # DTO is disabled
            yes_no "${REF_NAMES[$1]} $MSG_DIS"
            if [ $? -eq 0 ]; then
                SGST_REBOOT=1
                dto_write enable $1
            else
                BAILED=1
            fi
        else
            # no DTO ref exists, add the requested DTO
            yes_no "${REF_NAMES[$1]} $MSG_DIS"
            if [ $? -eq 0 ]; then
                SGST_REBOOT=1
                dto_write add $1
            else
                BAILED=1
            fi
        fi
    fi
}


dtp_probe()
{
    # Test for config option
    DTP_ENABLED=$(grep -cim1 ^dtparam=$1 $CFG_TXT)
    DTP_DISABLED=$(grep -cim1 "^# *dtparam=$1" $CFG_TXT)
    DTP_VAL=$(grep -E "^dtparam=$1|^#dtparam=$1" $CFG_TXT| sed "s/.*$1=//")
}


dtp_enable()
{
    dtp_probe $1
    if [ $DTP_DISABLED -eq 1 ]; then
        dtp_write enable $1
        SGST_REBOOT=1
    elif [ $DTP_ENABLED -ne 1 ]; then
        dtp_write add $1
        SGST_REBOOT=1
    fi
}


dtp_disable()
{
    dtp_probe $1
    if [ $DTP_ENABLED -eq 1 ]; then
        dtp_write disable $1
        SGST_REBOOT=1
    fi
}


dtp_write()
{
    if [ $1 == "enable" ]; then
        sed -i "s/^# *dtparam=$2/dtparam=$2/" $CFG_TXT
    elif [ $1 == "add" ]; then
        echo "dtparam=$2=${DEF_VALS[$2]}" >> $CFG_TXT
    elif [ $1 == "disable" ]; then
        sed -i "s/^dtparam=$2/#dtparam=$2/" $CFG_TXT
    fi
}


dyn_dto_add()
{
    # Sometimes we don't want DTO's loaded dynamically (eg. vc4!)
    [ "$DYN_DTO" == "false" ] && return 0

    # 1st arg = DTO name; 2nd arg = new parameter
    if [ "$2" != "" ]; then
        if ! dtoverlay -l |grep -c "$2"; then
            dtoverlay $1 $2
        fi
    elif [ "$2" == "" ]; then
        if ! dtoverlay -l |grep -c "$1"; then
            dtoverlay $1
        fi
    fi

    [ $? -eq 0 ] && SGST_REBOOT=0

    unset DYN_DTO
} &>>$FDSC


dyn_dto_rem()
{
    if dtoverlay -l |grep -c "$1"; then
        dtoverlay -R $1
        [ $? -eq 0 ] && SGST_REBOOT=0
    fi
} &>>$FDSC


dtp_ask()
{
    # reset for each selection
    BAILED=0
    OPT_DISABLED=0

    if [[ "$@" =~ "--reverse" ]]; then
        MSG_DIS=$TXT_ENB
        MSG_ENB=$TXT_DIS
    else
        MSG_DIS=$TXT_DIS
        MSG_ENB=$TXT_ENB
    fi

   # test for config.txt option
    dtp_probe $1

    if [ $DTP_ENABLED -eq 1 ]; then
        # dtp ref is enabled already
        yes_no "${REF_NAMES[$1]} $MSG_ENB"
        if [ $? -eq 0 ]; then
            dtp_write disable $1
            SGST_REBOOT=1
            OPT_DISABLED=1
        else
            BAILED=1
        fi
    elif [ $DTP_DISABLED -eq 1 ]; then
        # dtp ref is disabled
        yes_no "${REF_NAMES[$1]} $MSG_DIS"
        if [ $? -eq 0 ]; then
            dtp_write enable $1
            SGST_REBOOT=1
        else
            BAILED=1
        fi
    else
        # no dtp ref exists, add it
        yes_no "${REF_NAMES[$1]} $MSG_DIS"
        if [ $? -eq 0 ]; then
            dtp_write add $1
            SGST_REBOOT=1
        else
            BAILED=1
        fi
    fi
}



cfg_probe()
{
    # Test for config option
    CFG_ENABLED=$(grep -cim1 ^$1 $CFG_TXT)
    CFG_DISABLED=$(grep -cim1 "^# *$1" $CFG_TXT)
    CFG_VAL=$(grep -E "^$1|^#$1" $CFG_TXT| sed "s/.*$1=//")
}


cfg_enable()
{
    # 1st arg = config name; 2nd arg (if any) = new parameter value
    cfg_probe $1
    if [ $CFG_DISABLED -eq 1 ]; then
        cfg_write enable $1
        SGST_REBOOT=1
    elif [ $CFG_ENABLED -ne 1 ]; then
        cfg_write add $1
        SGST_REBOOT=1
    fi

    if [ ! $2 == "" ]; then
        cfg_val_update $1 $2
        SGST_REBOOT=1
    fi
}


cfg_disable()
{
    cfg_probe $1
    if [ $CFG_ENABLED -eq 1 ]; then
        cfg_write disable $1
        SGST_REBOOT=1
    fi
}


cfg_write()
{
    if [ $1 == "enable" ]; then
        sed -i "s/^# *$2/$2/" $CFG_TXT
    elif [ $1 == "add" ]; then
        echo "$2=${DEF_VALS[$2]}" >> $CFG_TXT
    elif [ $1 == "disable" ]; then
        sed -i "s/^$2/#$2/" $CFG_TXT
    fi
}


cfg_ask()
{
    # reset for each selection
    BAILED=0
    OPT_DISABLED=0

    if [[ "$@" =~ "--reverse" ]]; then
        MSG_DIS=$TXT_ENB
        MSG_ENB=$TXT_DIS
    else
        MSG_DIS=$TXT_DIS
        MSG_ENB=$TXT_ENB
    fi

   # test for config.txt option
    cfg_probe $1

    if [ $CFG_ENABLED -eq 1 ]; then
        # config ref is enabled already
        yes_no "${REF_NAMES[$1]} $MSG_ENB"
        if [ $? -eq 0 ]; then
            cfg_write disable $1
            SGST_REBOOT=1
            OPT_DISABLED=1
        else
            BAILED=1
        fi
    elif [ $CFG_DISABLED -eq 1 ]; then
        # config ref is disabled
        yes_no "${REF_NAMES[$1]} $MSG_DIS"
        if [ $? -eq 0 ]; then
            cfg_write enable $1
            SGST_REBOOT=1
        else
            BAILED=1
        fi
    else
        # no config ref exists, add it
        yes_no "${REF_NAMES[$1]} $MSG_DIS"
        if [ $? -eq 0 ]; then
            cfg_write add $1
            SGST_REBOOT=1
        else
            BAILED=1
        fi
    fi
}


cfg_check()
{
    # We need a config.txt
    if [ ! -f $CFG_TXT ]; then
        echo "Can't find $CFG_TXT\nPlease check your system!"
        # Offer the option to create one here?
        exit 1
    fi

    # NOTE: It adds another layer of complexity to deal with device_tree_param,
    # dtparam and device_tree_overlay/dtoverlay refs independently. So if found,
    # just replace them all accordingly.

    if [[ $(grep -cim1 device_tree_param $CFG_TXT) -eq 1 ]]; then
        sed -i 's/device_tree_param/dtparam/' $CFG_TXT
    fi

    if [[ $(grep -cim1 device_tree_overlay $CFG_TXT) -eq 1 ]]; then
        sed -i 's/device_tree_overlay/dtoverlay/' $CFG_TXT
    fi
}


cfg_val_update()
{
    # 1st arg = config / paramater name; 2nd arg = new parameter value
    sed -i "s/^$1=.*$/$1=$2/" $CFG_TXT
}


boot_kernel()
{
    VMLINUZ=vmlinuz-$1
    KERNEL_DIR=$MODULES_DIR/$1

    # find & set the kernel's dtb dir
    if [ -d "$KERNEL_DIR/dtb" ]; then
        DTB_DIR=$KERNEL_DIR/dtb
    elif [ -d "$BOOT_DIR/dtb-$1" ]; then
        DTB_DIR=$BOOT_DIR/dtb-$1
    else
        msg "ERROR:" "Can't find DTB dir for selected kernel. Aborting."
        return 0
    fi

    if [ "$ARCH" == "armv7hl" ]; then
        KERN_IMG=$BOOT_DIR/kernel7.img
    else
        KERN_IMG=$BOOT_DIR/kernel.img
    fi

    # NOTE The bcm2708_fb driver is used downstream but not upstream,
    # making it a suitable predicate symbol.
    if [ -f "$KERNEL_DIR/System.map" ]; then
        KERN_DOWN=$(grep -cim1 bcm2708_fb $KERNEL_DIR/System.map)
    elif [ -f "$BOOT_DIR/System.map-$1" ]; then
        KERN_DOWN=$(grep -cim1 bcm2708_fb $BOOT_DIR/System.map-$1)
    else
        KERN_DOWN=0
    fi

    ### Clean and copy over dtb files
    rm -fv $BOOT_DIR/*.dtb &>>$FDSC

    if [ $KERN_DOWN -eq 1 ] ; then
        if [ "$ARCH" == "armv7hl" ]; then
            cp -fv $DTB_DIR/bcm2709* $BOOT_DIR/ &>>$FDSC
            cp -fv $DTB_DIR/bcm2710* $BOOT_DIR/ &>>$FDSC
        else
            # assume its armv6hl arch
            cp -fv $DTB_DIR/dtb/bcm2708* $BOOT_DIR/ &>>$FDSC
        fi
    else
        cp -fv $DTB_DIR/dtb/bcm28* $BOOT_DIR/ &>>$FDSC
    fi

    ### Copy selected kernel
    if [ -f $KERNEL_DIR/vmlinuz ]; then
        cp -fv $KERNEL_DIR/vmlinuz $KERN_IMG &>>$FDSC
    elif [ -f $BOOT_DIR/$VMLINUZ ]; then
        cp -fv $BOOT_DIR/$VMLINUZ $KERN_IMG &>>$FDSC
    else
        msg "ERROR:" "Can't find selected kernel image. Aborting."
        return 0
    fi

    ### Clean and copy overlays for downstream/custom kerenls
    rm -fv $BOOT_DIR/overlays/* &>>$FDSC

    if [ -d "$DTB_DIR/overlays" ]; then
        cp -v $DTB_DIR/overlays/* $BOOT_DIR/overlays/ &>>$FDSC
    fi

    SGST_REBOOT=1
    msg "The $1 kernel will be used when $OS_NAME $OS_VER_ID is rebooted"
}


vc4_ask()
{
    DYN_DTO=false dto_ask $1
    if [[ $BAILED -ne 1 ]] && [[ $NO_OVERLAY -ne 1 ]]; then
        if [[ $DRV_DISABLED -eq 1 ]]; then
            vc4_disable
        else
            vc4_enable $1
        fi
    fi
}


vc4_enable()
{
    cfg_disable gpu_mem
    # currently conflicts with pi camera requirements
    cfg_disable start_x
    # the two vc4 overlays conflict with one another
    if [ "$1" == "vc4-fkms-v3d" ]; then
        dto_disable vc4-kms-v3d
    elif [ "$1" == "vc4-kms-v3d" ]; then
        dto_disable vc4-fkms-v3d
    fi
    # check fbturbo driver conf and disable if exists
    for i in /etc/X11/xorg.conf.d /usr/share/X11/xorg.conf.d; do
        FBTURBO_CONF=$(grep -Hsl fbturbo $i/*.conf)
        if [ $? -eq 0 ]; then
            mv -fv $FBTURBO_CONF $FBTURBO_CONF.bak &>>$FDSC
        fi
    done
}


vc4_disable()
{
    cfg_enable gpu_mem
    # check for & re-enable fbturbo driver if exists
    if rpm -q xorg-x11-drv-fbturbo &>>$FDSC; then
        for i in /etc/X11/xorg.conf.d /usr/share/X11/xorg.conf.d; do
            FBTURBO_BAK=$(grep -Hsl fbturbo $i/*.bak)
            if [ $? -eq 0 ]; then
                FBTURBO_CONF=$(echo $FBTURBO_BAK |sed 's|\.bak||')
                mv -fv $FBTURBO_BAK $FBTURBO_CONF &>>$FDSC
            fi
        done
    fi
}


pi_camera()
{
    cfg_ask start_x
    if [[ $BAILED -ne 1 ]]; then
        if [[ $OPT_DISABLED -ne 1 ]]; then
            cfg_enable gpu_mem
            # currrently conflicts with the vc4 driver requirements
            dto_disable vc4-kms-v3d
            dto_disable vc4-fkms-v3d
            [[ $CFG_VAL -lt 128 ]] && cfg_val_update gpu_mem 128
        fi
    fi
}


bt_ask()
{
    if hcitool dev |grep hci &>>$FDSC || systemctl is-enabled brcm43438.service &>>$FDSC; then
        yes_no "DISABLE RPi 3 Bluetooth" "Do you want to DISABLE bluetooth support for your RPi 3?"
        [ $? == 1 ] && return 0 || bt_disable
    else
        yes_no "ENABLE RPi 3 Bluetooth" "Do you want to ENABLE bluetooth support for your RPi 3?"
        [ $? == 1 ] && return 0 || bt_enable
    fi
}


bt_enable()
{
    rpi_req 3; [ $? == 1 ] && return

    # check for software support
    if ! rpm -q bluetooth-rpi3 &>>$FDSC; then
        msg "The bluetooth-rpi3 package is not installed, please install.\n\nFor example: dnf install bluetooth-rpi3"
        return 0
        # Need to spend some time figuring out how to wrap dnf with progress bar code
        # so we can offer to install required pachages when not found.
        #if [ $? == 0 ]; then
        #    dnf -y --quiet install bluetooth-rpi3
        #fi
    fi

    # ensure pi3-disable-bt overlay is disabled
    dto_disable pi3-disable-bt

    # enable / start systemd service
    systemctl enable brcm43438.service &>>$FDSC
    systemctl start brcm43438.service &>>$FDSC
}


bt_disable()
{
    # stop & disable systemd service
    systemctl stop brcm43438.service
    systemctl disable brcm43438.service

    # enable pi3-disable-bt overlay
    dto_enable pi3-disable-bt
} &>>$FDSC


rpi_req()
{
    MODEL=$1
    # bail if not the requested model no.
    if ! echo $RPI_MODEL |grep -c "Raspberry Pi $MODEL" &>>$FDSC; then
        msg "Raspberry Pi $MODEL Model B not found, can not proceed"
        return 1
    else
        return 0
    fi
}


rpi_oc()
{
    if [ "$1" == "disable" ]; then
        for i in arm_freq core_freq sdram_freq over_voltage; do
            cfg_disable $i
        done
        msg "RPi Overclock Preset" "Overclocking support has been disabled."
    else
        cfg_enable arm_freq $1
        cfg_enable core_freq $2
        cfg_enable sdram_freq $3
        cfg_enable over_voltage $4

        msg "RPi Overclock Preset" "Updated overclock settings are:\n
Frequency ARM = $1 MHz\nFrequency GPU core = $2 MHz
Frequency SDRAM = $3 MHz\nARM/GPU core voltage adjust = $4\
\n\nPlease reboot to apply updated overclocking settings."
    fi
}


bootsplash()
{
    SPLASH_OPTS="rhgb plymouth.ignore-serial-consoles logo.nologo"

    if [ $OS_VER_ID -lt 25 ]; then
        msg "Plymouth Graphical Bootsplash" "Plymouth graphical bootsplash is currently unsupported in FedBerry $OS_VER_ID"
        return 0
    fi

    if [ "$1" == "enable" ]; then
        for i in $SPLASH_OPTS; do
            if ! grep -q "$i" $CMD_TXT; then
                sed -i "1s/$/ $i/" $CMD_TXT
            fi
        done
        msg "Plymouth graphical bootsplash has been enabled."
    elif [ "$1" == "disable" ]; then
        for i in $SPLASH_OPTS; do
            if grep -q "$i" $CMD_TXT; then
                sed -i "s/ $i//" $CMD_TXT
            fi
        done
        msg "Plymouth graphical bootsplash has been disabled."
    fi
}


swap_add()
{
    # we need an argument
    if [[ "$1" == "" ]]; then
        echo "Missing argument"
        return 0
    fi

    # check for existing swap file
    if [[ "$(swapon --show --noheadings)" != "" ]]; then
        msg "Existing swap file/partition found, can not proceed."
        return 0
    fi

    # check for sufficient disk space (swap + min 1GB extra?)
    ROOTFS_INFO=( $(df |grep " /$") )
    ROOTFS_FREE=$(echo ${ROOTFS_INFO[3]})
    SWAP_REQ=$(($1 * 1024))
    REQ_FREE=$(($SWAP_REQ + 1048576))

    if [ $ROOTFS_FREE -lt $REQ_FREE ]; then
        msg "Insufficient free space on rootfs."
        return 0
    fi

    # create swap file & format it.
    SWAP_MSG="Creating $1MB swap file, please wait..."

    if [ $NO_DIALOG -eq 1 ]; then
        msg "$SWAP_MSG"
        pv -p --size "$1"M -S /dev/zero | dd of=/swapfile bs=1k count="$1"k status=noxfer
        mkswap /swapfile
    else
        (pv -n --size "$1"M -S /dev/zero | dd of=/swapfile bs=1k count="$1"k status=noxfer && mkswap /swapfile) 2>&1 | dialog_prog "$SWAP_MSG"
    fi

    # could we use fallocate here as its much faster? or will we end up with a sparse file?
    # Note: Btrfs does not support swap files and fallocate may cause problems with F2FS or XFS
    # fallocate -l '$1'M /swapfile

    # world readable swap files are a huge local vulnerability
    chmod 600 /swapfile &>>$FDSC

    # activate it
    swapon /swapfile &>>$FDSC

    # enable it at boot
    echo "/swapfile swap swap defaults 0 0" >>/etc/fstab
}


rootfs_ask()
{
    yes_no "Expand Root Filesystem" "Do you want to grow your root filesystem?\n\nWARNING: Before continuing, please save any work as the system will automatically reboot after re-partitioning"
        if [ $? == 0 ]; then
            touch /.rootfs-repartition
            rootfs_grow
        fi
}


rootfs_grow()
{
    # Do we need to repartition?
    [ ! -e /.rootfs-repartition ] && return 0

    # Check for kernel cmdline parameter 'nofsresize'
    [ $(cat /proc/cmdline |grep -cim1 nofsresize) -eq 1 ] && return 0

    # Get root device
    ROOT_PART=$(mount |awk '/on \/ type/ { print $1 }')

    if [ ! -e /.rootfs-grow ]; then
        # Show plymouth notification
        plymouth message --text="Expanding root partition. Please wait." && sleep 1

        # Grab required partition & block device information
        BLK_DEV=$(echo ${ROOT_PART//[p,1-9]/})
        DEV_INFO=$(fdisk -l $BLK_DEV)
        PART_INFO=( $(echo "$DEV_INFO" |awk 'END{print}') )
        LAST_PART=$(echo ${PART_INFO[0]})

        if [ "$ROOT_PART" != "$LAST_PART" ]; then
            msg "Root partition $ROOT_PART is not the last partiton. Can not proceed."
            rm -fv /.rootfs-repartition &>>$FDSC
            systemctl disable rootfs-grow.service &>>$FDSC
            return 0
        fi

        SIZE_INFO=( $(echo "$DEV_INFO" |grep "Disk $BLK_DEV") )
        TOTAL_SECTS=$(echo ${SIZE_INFO[6]})
        START_SECT=$(echo ${PART_INFO[1]})
        END_SECT=$(echo ${PART_INFO[2]})
        PART_NUM=$(echo ${ROOT_PART//[!1-9]/})
        FREE_SECTS=$(($TOTAL_SECTS - $END_SECT))

        # Ensure there is enough space to grow the root partition
        if [ $FREE_SECTS -lt 10 ]; then
            msg "Not enough space remaining on $ROOT_PART. The root parition can not be further expanded."
            rm -fv /.rootfs-repartition &>>$FDSC
            systemctl disable rootfs-grow.service &>>$FDSC
            return 0
        fi

        # Uggh! I know, this is an ugly hack but at the moment I just don't trust parted
        # to do the job on SD cards >=64GB. It seems to mess things up!
        echo -e "\np\nd\n$PART_NUM\nn\np\n$PART_NUM\n$START_SECT\n\nw"| fdisk $BLK_DEV &>>$FDSC

        touch /.rootfs-grow
        systemctl enable rootfs-grow.service &>>$FDSC
        plymouth message --text="Rebooting Fedberry" && sleep 1
        systemctl reboot &>>$FDSC
    else
        plymouth message --text="Finalizing expansion of root filesystem."
        resize2fs $ROOT_PART &>>$FDSC
        rm -fv /.rootfs-grow /.rootfs-repartition &>>$FDSC

        # Don't want it running every boot as its job is already done.
        systemctl disable rootfs-grow.service &>>$FDSC
    fi
}


selinux()
{
    # if needed, get current selinux mode
    [ ! -v SE_MODE ] && sys_info

    # Selinux-policy needs to be installed
    if [ ! -e $SE_CFG ]; then
        msg "selinux-policy is not installed. Can not enable selinux."
        return 0
    fi

    MSG_RLB="SELinux is now set to $1 mode.\n\nPlease reboot to enable SELinux & relabel the file system.\n\nPlease Note: Relabeling may take a long time, depending on file system size."

    if [[ "$SE_MODE" == "Enforcing" ]]; then
        if [[ "$1" == "enforcing" ]]; then
            selinux_enable $1
            msg "SELinux is set to $1 mode"
        elif [[ "$1" == "permissive" ]]; then
            setenforce 0
            selinux_enable $1
            msg "SELinux is now set to $1 mode"
        elif [[ "$1" == "disabled" ]]; then
            selinux_disable
            SGST_REBOOT=1
        fi
    fi

    if [[ "$SE_MODE" == "Permissive" ]]; then
        if [[ "$1" == "enforcing" ]]; then
            setenforce 1
            selinux_enable $1
            msg "SELinux is now set to $1 mode"
        elif [[ "$1" == "permissive" ]]; then
            selinux_enable $1
            msg "SELinux is set to $1 mode"
        elif [[ "$1" == "disabled" ]]; then
            selinux_disable
            SGST_REBOOT=1
        fi
    fi

    if [[ "$SE_MODE" == "Disabled" ]]; then
        if [[ "$1" == "enforcing" ]]; then
            selinux_enable $1
            msg "$MSG_RLB"
            SGST_REBOOT=1
        elif [[ "$1" == "permissive" ]]; then
            selinux_enable $1
            msg "$MSG_RLB"
            SGST_REBOOT=1
        elif [[ "$1" == "disabled" ]]; then
            msg "SELinux is already disabled"
            sed -i 's/^SELINUX=.*/SELINUX=disabled/' $SE_CFG
            if ! grep -q "selinux=0" $CMD_TXT; then
                sed -i '1s/$/ selinux=0/' $CMD_TXT
            fi
        fi
    fi
}


selinux_disable()
{
    # Temporarily set permissive mode until selinux is disabled at next boot
    setenforce 0
    [ `grep -q "selinux=0" $CMD_TXT` ] || sed -i '1s/$/ selinux=0/' $CMD_TXT
    [ `grep -q "selinux=1" $CMD_TXT` ] && sed -i 's/selinux=1/selinux=0/' $CMD_TXT
    sed -i 's/^SELINUX=.*/SELINUX=disabled/' $SE_CFG
    msg "SELinux has been disabled.\n\nPlease reboot your system to apply changes."
}

selinux_enable()
{
    sed -i -e 's/ selinux=0//' -e 's/ audit=0//' $CMD_TXT
    sed -i "s/^SELINUX=.*/SELINUX=$1/" $SE_CFG
}


led_ask()
{
    if [[ "$1" = ACT ]]; then
        LED=act
        LED_SYS=led0
    elif [[ "$1" = PWR ]]; then
        LED=pwr
        LED_SYS=led1
    fi

    dtp_ask "$LED"_led_activelow --reverse
    if [[ $BAILED -ne 1 ]]; then
        if [[ $OPT_DISABLED -ne 1 ]]; then
            dtp_enable "$LED"_led_activelow
            dtp_enable "$LED"_led_trigger
            echo 0 >/sys/class/leds/$LED_SYS/brightness
            echo none >/sys/class/leds/$LED_SYS/trigger
            if [[ "$RPI_MODEL" =~ "Pi 3 Model B Rev" ]] && [[ "$1" = PWR ]]; then
                systemctl enable pi3_disable_pwr_led.service &>>$FDSC
            fi
        else
            dtp_disable "$LED"_led_activelow
            dtp_disable "$LED"_led_trigger
            echo 1 >/sys/class/leds/$LED_SYS/brightness
            if [[ "$1" = ACT ]]; then
                echo mmc0 >/sys/class/leds/$LED_SYS/trigger
            fi
            if [[ "$RPI_MODEL" =~ "Pi 3 Model B Rev" ]] && [[ "$1" = PWR ]]; then
                systemctl disable pi3_disable_pwr_led.service &>>$FDSC
            fi
        fi
    fi

    SGST_REBOOT=0
}


alsa_output()
{
    if [ -f /proc/asound/version ]; then
        if [ ! -f /usr/bin/amixer ]; then
            msg "ERROR: Amixer not found." "Please install alsa-utils package."
        else
            amixer cset numid=3 "$1" &>>$FDSC
            if [ $? -eq 0 ]; then
                msg "ALSA audio output set to: $2"
            else
                msg "ERROR" "FAILED to set ALSA output to: $2\n\nPlease check logs."
            fi
        fi
    else
        msg "ERROR" "FAILED to set ALSA output to: $2\n\nALSA sound system is not running!"
    fi
}


menu_rpi2_oc()
{
    rpi_req 2; [ $? == 1 ] && return

    yes_no "RPi2 Overclocking" "Please Note: Overclocking your RPi 2 may cause \
system instability. If your RPi 2B fails to boot, holding down shift during \
boot up will temporarily disable overclocking.\n\nRefer \
http://elinux.org/RPi_Overclocking for more information.\n\n
Do you wish to continue?"
    [ $? == 1 ] && return

    local MENU_TITLES=(
    "RPi2 Overclocking" "Choose Overclock Preset")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. None (Disabled) " "Disable overclocking"
    "2. High " "1000MHz ARM, 500MHz GPU core, 500MHz SDRAM, 2 overvolt")

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="rpi_oc disable; break"
    [${MENU_ITEMS[2]}]="rpi_oc 1000 500 500 2; break")

    dialog_menu $MENU_ARGS
}


menu_bootsplash()
{
    local MENU_TITLES=(
    "Plymouth Bootsplash" "Choose Bootsplash Options")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. Enable Bootsplash " "Enable plymouth graphical bootsplash"
    "2. Disable Bootsplash " "Disable plymouth graphical bootsplash")

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="bootsplash enable ; break"
    [${MENU_ITEMS[2]}]="bootsplash disable ; break")

    dialog_menu $MENU_ARGS
}


menu_led()
{
    local MENU_TITLES=(
    "ACT/PWR LEDs" "Choose LED Options")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. ACT LED" "Enable/disable green activity (ACT) LED"
    "2. ACT LED" "Enable/disable red power (PWR) LED")

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="led_ask ACT ; break"
    [${MENU_ITEMS[2]}]="led_ask PWR ; break")

    dialog_menu $MENU_ARGS
}


menu_selinux()
{
    sys_info # Get SE_MODE

    local MENU_TITLES=(
    "SELinux Status: $SE_MODE" "Choose SELinux Mode:")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. Set Enforcing Mode" "Security policy is enforced"
    "2. Set Permissive Mode" "Print warnings instead of enforcing"
    "3. Disable SELinux" "SELinux is Disabled")

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="selinux enforcing ; break"
    [${MENU_ITEMS[2]}]="selinux permissive ; break"
    [${MENU_ITEMS[4]}]="selinux disabled ; break")

    dialog_menu $MENU_ARGS
}


menu_vc4()
{
    # First, check for enabled vc4 & offer to disable
    for i in vc4-fkms-v3d vc4-kms-v3d; do
        dto_probe $i
        if [ $DTO_ENABLED == 1 ]; then
            yes_no "${REF_NAMES[$i]} $TXT_ENB"
            if [ $? == 0 ]; then
                dto_disable $i
                vc4_disable; return
            fi
        fi
    done

    msg "WARNING" "The Mesa VC4 driver is EXPERIMENTAL and a W.I.P. It will likely cause system instability."

    local MENU_TITLES=(
    "VC4 Driver Selection" "Choose the VC4 driver:")

    local MENU_BUTTONS=("Select" "Cancel")

    ### VC4 'fake' KMS seems to be broken lately (especially for > 4.19.x kernels)
    sys_info
    if [[ "$KERN_VER" > "4.19" ]]; then
        local MENU_ITEMS=(
        "1. VC4 KMS " "Full KMS DRM VC4 HDMI/HVS/V3D driver")

        declare -A MENU_ACTIONS=(
        [${MENU_ITEMS[0]}]="vc4_ask vc4-kms-v3d; break")
    else
        local MENU_ITEMS=(
        "1. VC4 Fake KMS " "DRM VC4 driver using dispmanx display stack (fake KMS)"
        "2. VC4 KMS " "Full KMS DRM VC4 HDMI/HVS/V3D driver")

        declare -A MENU_ACTIONS=(
        [${MENU_ITEMS[0]}]="vc4_ask vc4-fkms-v3d; break"
        [${MENU_ITEMS[2]}]="vc4_ask vc4-kms-v3d; break")
    fi

    dialog_menu $MENU_ARGS
}


menu_kernel()
{
    # get current running kernel version
    sys_info

    local MENU_TITLES=(
    "Current running kernel version: $KERN_VER" "Select the kernel version for next boot:")

    local MENU_BUTTONS=("Select" "Cancel")

    # list installed kernels
    KERNEL_LIST=( $(ls $MODULES_DIR) )

    local MENU_ITEMS
    declare -A MENU_ACTIONS

    for i in `seq 1 ${#KERNEL_LIST[@]}`; do
        MENU_ITEMS=("${MENU_ITEMS[@]}" "$i. Kernel" "${KERNEL_LIST[$(($i-1))]}")
        MENU_ACTIONS["$i. Kernel"]="boot_kernel ${KERNEL_LIST[$(($i-1))]} ; break"
    done

    dialog_menu $MENU_ARGS
}


menu_swap()
{
    local MENU_TITLES=(
    "Swap File Selection" "Choose required swap file size")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. 256 MB " "Create and enable a 256MB swap file"
    "2. 512 MB " "Create and enable a 512MB swap file"
    "3. 1024 MB  " "Create and enable a 1024MB (1GB) swap file")

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="swap_add 256 ; break"
    [${MENU_ITEMS[2]}]="swap_add 512 ; break"
    [${MENU_ITEMS[4]}]="swap_add 1024 ; break")

    dialog_menu $MENU_ARGS
}


menu_fb_depth()
{
    FB_DEPTH=$(fbset |awk '/geometry/ { print $6 }')

    local MENU_TITLES=(
    "Current Console Framebuffer Depth: $FB_DEPTH bits" "\nSelect new colour depth:")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. 16 bit " "Set console framebuffer colour depth 16 bits "
    "2. 24 bit " "Set console framebuffer colour depth 24 bits "
    "3. 32 bit " "Set console framebuffer colour depth 32 bits (Default)"
    )

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="cfg_enable framebuffer_depth 16; break"
    [${MENU_ITEMS[2]}]="cfg_enable framebuffer_depth 24; break"
    [${MENU_ITEMS[4]}]="cfg_enable framebuffer_depth 32; break"
    )

    dialog_menu $MENU_ARGS
}


menu_gpu_mem()
{
    sys_info

    local MENU_TITLES=(
    "Current allocated GPU memory: $GPU_MEM MB" "Choose new GPU memory allocation")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. 16 MB " "Allocate 16 MB of system memory to the GPU"
    "2. 32 MB " "Allocate 32 MB of system memory to the GPU"
    "3. 64 MB " "Allocate 64 MB of system memory to the GPU"
    "4. 96 MB  " "Allocate 96 MB of system memory to the GPU"
    "5. 128 MB  " "Allocate 128 MB of system memory to the GPU"
    "6. 192 MB  " "Allocate 192 MB of system memory to the GPU"
    "7. 256 MB  " "Allocate 256 MB of system memory to the GPU"
    )

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="cfg_enable gpu_mem 16; msg '16 $TXT_GPU_MEM'; break"
    [${MENU_ITEMS[2]}]="cfg_enable gpu_mem 32; msg '32 $TXT_GPU_MEM'; break"
    [${MENU_ITEMS[4]}]="cfg_enable gpu_mem 64; msg '64 $TXT_GPU_MEM'; break"
    [${MENU_ITEMS[6]}]="cfg_enable gpu_mem 96; msg '96 $TXT_GPU_MEM'; break"
    [${MENU_ITEMS[8]}]="cfg_enable gpu_mem 128; msg '128 $TXT_GPU_MEM'; break"
    [${MENU_ITEMS[10]}]="cfg_enable gpu_mem 192; msg '192 $TXT_GPU_MEM'; break"
    [${MENU_ITEMS[12]}]="cfg_enable gpu_mem 256; msg '256 $TXT_GPU_MEM'; break"
    )

    dialog_menu $MENU_ARGS
}


menu_rtc()
{
    # We don't have to enable i2c interface first here as the DTO should
    # automatically enable it (refer: /boot/overlay/README)
    dto_ask i2c-rtc

    # check we haven't bailed or disabled the driver
    [ $BAILED -eq 1 -o $DRV_DISABLED -eq 1 ] && return

    # ensure nortc is not in cmdline.txt
    sed -i 's/ nortc//' $CMD_TXT &>>$FDSC

    local MENU_TITLES=(
    "RTC Device Selection" "Choose your I2C Real Time Clock device")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. abx80x " "Select the abx80x family"
    "2. DS1307 " "Select the DS1307 device"
    "3. DS1339 " "Select the DS1339 device"
    "4. DS3231  " "Select the DS3231 device"
    "5. MCP7940x " "Select the MCP7940x device"
    "6. MCP7941x " "Select the MCP7941x device"
    "7. PCF2127 " "Select the PCF2127 device"
    "8. PCF8523 " "Select the PCF8523 device"
    "9. PCF8563 " "Select the PCF8563 device")

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="dto_prm_update i2c-rtc abx80x; break"
    [${MENU_ITEMS[2]}]="dto_prm_update i2c-rtc ds1307; break"
    [${MENU_ITEMS[4]}]="dto_prm_update i2c-rtc ds1339; break"
    [${MENU_ITEMS[6]}]="dto_prm_update i2c-rtc ds3231; break"
    [${MENU_ITEMS[8]}]="dto_prm_update i2c-rtc mcp7940x; break"
    [${MENU_ITEMS[10]}]="dto_prm_update i2c-rtc mcp7941x; break"
    [${MENU_ITEMS[12]}]="dto_prm_update i2c-rtc pcf2127; break"
    [${MENU_ITEMS[14]}]="dto_prm_update i2c-rtc pcf8523; break"
    [${MENU_ITEMS[16]}]="dto_prm_update i2c-rtc pcf8563; break")

    dialog_menu $MENU_ARGS
}


menu_main()
{
    local MENU_TITLES=("Main Menu" "Choose an Option")

    local MENU_BUTTONS=("Select" "Exit")

    local MENU_ITEMS=(
    "1. System" "Configure various system options"
    "2. RPi Interfaces" "Configure RPi hardware interfaces"
    "3. Video/Display" "Configure video & display devices"
    "4. Audio" "Configure audio devices"
    "5. Network" "Configure network devices"
    "6. Misc" "Configure miscellaneous hardware devices"
    "7. System Info" "Show current system information"
    "8. About" "Information about this configuration utility")

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]=menu_system
    [${MENU_ITEMS[2]}]=menu_intfce
    [${MENU_ITEMS[4]}]=menu_video
    [${MENU_ITEMS[6]}]=menu_audio
    [${MENU_ITEMS[8]}]=menu_network
    [${MENU_ITEMS[10]}]=menu_misc
    [${MENU_ITEMS[12]}]=show_info
    [${MENU_ITEMS[14]}]=about)

    dialog_menu $MENU_ARGS
}


menu_system()
{
    local MENU_TITLES=("System Configuration" "Choose an Option")

    local MENU_BUTTONS=("Select" "Main Menu")

    local MENU_ITEMS=(
    "1. Set Boot Kernel" "Select kernel to use for booting the system"
    "2. Bootsplash" "Enable/disable plymouth graphical bootsplash"
    "3. ACT/PWR LED's" "Enable/disable ACT/PWR LED's"
    "4. SELinux" "Configure SELinux options"
    "5. Add Swap File" "Add and enable a swap file"
    "6. Expand Root FS" "Expand (grow) root filesystem on SD card"
    "7. Overclock RPi2" "Configure overclocking for RPi2"
    )

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]=menu_kernel
    [${MENU_ITEMS[2]}]=menu_bootsplash
    [${MENU_ITEMS[4]}]=menu_led
    [${MENU_ITEMS[6]}]=menu_selinux
    [${MENU_ITEMS[8]}]=menu_swap
    [${MENU_ITEMS[10]}]=rootfs_ask
    [${MENU_ITEMS[12]}]=menu_rpi2_oc
    )

    dialog_menu $MENU_ARGS
}


menu_intfce()
{
    local MENU_TITLES=(
    "Enable/Disable Hardware Interfaces" "Choose an Option")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. I2C interface" "Inter-Integrated Circuit (i2c) interface"
    "2. I2S interface" "Inter-IC Sound, (i2s) interface"
    "3. SPI interface" "Serial Peripheral Interface")

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="dtp_ask i2c"
    [${MENU_ITEMS[2]}]="dtp_ask i2s"
    [${MENU_ITEMS[4]}]="dtp_ask spi")

    dialog_menu $MENU_ARGS
}


menu_video()
{
    local MENU_TITLES=(
    "Enable/Disable Video & Display Devices" "Choose an Option")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. Pi Camera" "Enable/disable the RPi Camera"
    "2. Allocate GPU Memory" "Set amount of system memory allocated to the GPU"
    "3. Colour Depth" "Set console framebuffer colour depth"
    "4. Rainbow Splash" "Enable/disable inital rainbow boot splash"
    "5. Mesa DRM VC4" "Mesa/DRM VC4 driver for RPi (Experimental)")

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]=pi_camera
    [${MENU_ITEMS[2]}]=menu_gpu_mem
    [${MENU_ITEMS[4]}]=menu_fb_depth
    [${MENU_ITEMS[6]}]="cfg_ask disable_splash --reverse; SGST_REBOOT=0"
    [${MENU_ITEMS[8]}]=menu_vc4)

    dialog_menu $MENU_ARGS
}


menu_audio()
{
    local MENU_TITLES=(
    "Enable/Disable Audio Devices" "Choose an Option")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. RPi Audio" "Enable/Disable on-board ALSA interface"
    "2. RPi ALSA Out" "Choose ALSA audio output"
    "3. 3rd Party Devices" "Configure 3rd party audio devices"
    )

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="dtp_ask audio"
    [${MENU_ITEMS[2]}]=menu_alsa_out
    [${MENU_ITEMS[4]}]=menu_audio_3rd
    )

    dialog_menu $MENU_ARGS
}


menu_alsa_out()
{
    local MENU_TITLES=(
    "Choose ALSA audio output" "Select an Option")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. Auto" "Auto ALSA output"
    "2. Force Analog" "Force output to headphone jack (analog)"
    "3. Force HDMI" "Force output to HDMI"
    )

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="alsa_output 0 auto"
    [${MENU_ITEMS[2]}]="alsa_output 1 analog"
    [${MENU_ITEMS[4]}]="alsa_output 2 HDMI"
    )

    dialog_menu $MENU_ARGS
}


menu_audio_3rd()
{
    local MENU_TITLES=(
    "Enable/Disable 3rd Party Audio Devices" "Choose an Option")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. Allo Boss DAC" "Configure Allo Boss DAC audio card"
    "2. Allo Digione" "Configure Allo Digione audio card"
    "3. Fe-Pi Audio" "Configure Fe-Pi Audio sound card"
    "4. Google VoiceHAT" "Configure Google VoiceHAT sound card"
    "5. HifiBerry Amp" "Configure HifiBerry Amp & Amp+ audio cards"
    "6. HifiBerry DAC" "Configure HifiBerry DAC audio card"
    "7. HifiBerry DAC+" "Configure HifiBerry DAC+ audio card"
    "8. HifiBerry Digi" "Configure HifiBerry Digi & Digi+ audio cards"
    "9. HifiBerry D+Pro" "Configure HifiBerry Digi+ Pro audio card"
    "10. IQaudio DAC" "Configure IQaudio DAC audio card"
    "11. IQaudio DAC+" "Configure IQaudio DAC+ audio card"
    "12. IQaudio WM8804" "Configure IQAudIO Digi WM8804 audio card"
    "13. JustBoom DAC" "Configure DAC/Amp HAT & DAC/Amp Zero audio cards"
    "14. JustBoom Digi" "Configure JustBoom Digi Zero/HAT audio cards"
    )

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="dto_ask allo-boss-dac-pcm512x-audio"
    [${MENU_ITEMS[2]}]="dto_ask allo-digione"
    [${MENU_ITEMS[4]}]="dto_ask fe-pi-audio"
    [${MENU_ITEMS[6]}]="dto_ask googlevoicehat-soundcard"
    [${MENU_ITEMS[8]}]="dto_ask hifiberry-amp"
    [${MENU_ITEMS[10]}]="dto_ask hifiberry-dac"
    [${MENU_ITEMS[12]}]="dto_ask hifiberry-dacplus"
    [${MENU_ITEMS[14]}]="dto_ask hifiberry-digi"
    [${MENU_ITEMS[16]}]="dto_ask hifiberry-digi-pro"
    [${MENU_ITEMS[18]}]="dto_ask iqaudio-dac"
    [${MENU_ITEMS[20]}]="dto_ask iqaudio-dacplus"
    [${MENU_ITEMS[22]}]="dto_ask iqaudio-digi-wm8804-audio"
    [${MENU_ITEMS[24]}]="dto_ask justboom-dac"
    [${MENU_ITEMS[26]}]="dto_ask justboom-digi"
    )

    dialog_menu $MENU_ARGS
}


menu_network()
{
    local MENU_TITLES=(
    "Enable/Disable Network Devices" "Choose an Option")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. RPi3 Bluetooth" "Enable/disable RPi3 onboard Bluetooth"
    "2. RPi3 Wifi" "Enable/disable RPi3 onboard WiFi")

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="bt_ask"
    [${MENU_ITEMS[2]}]="rpi_req 3 && dto_ask pi3-disable-wifi --reverse")

    dialog_menu $MENU_ARGS
}


menu_misc()
{
    local MENU_TITLES=(
    "Enable/disable Miscellaneous Devices" "Choose an Option")

    local MENU_BUTTONS=("Select" "Cancel")

    local MENU_ITEMS=(
    "1. LIRC RPi" "Linux Infrared Remote Control for the RPi (LIRC)"
    "2. I2C RTC" "Realtime Clock (RTC) support")

    declare -A MENU_ACTIONS=(
    [${MENU_ITEMS[0]}]="dto_ask lirc-rpi"
    [${MENU_ITEMS[2]}]=menu_rtc)

    dialog_menu $MENU_ARGS
}


show_info()
{
    sys_info

    msg "System Information - $DATE_TIME" \
"<< OS >>
OS Release: $OS_NAME $OS_VER_ID ($ARCH)
SELinux Mode: $SE_MODE
Running Kernel: $KERN_VER
Memory Free (kB): $MEM_FREE
Memory Available (kB): $MEM_AVLB
\n<< HARDWARE >>
Model: $RPI_MODEL
Revision: $BOARD_REV (${MFG_INFO[$BOARD_REV]})
CPU Temp: $CPU_TEMP C
CPU Freq Current (MHz): $CPU_CUR
CPU Freq Maximum (MHz): $CPU_MAX
CPU Freq Minimum (MHz): $CPU_MIN"
}


about()
{
    msg "About $NAME - Version: $VERSION"  "\
$NAME allows for easy configuration of various \
system wide options in FedBerry. If you have heavily \
customised your FedBerry installation, some configure \
options may not function correctly.\n\n\
Copyright (C) $YEAR, $AUTHORS.\n\
$NAME is released under GPL licence version 3.\n\n\
Report issues to: $BUG_REPORTS"
}


usage()
{
echo "Usage: $NAME [OPTION] <overlay|paramater|option|value>

Configuration of various system wide options in FedBerry.

--dto-enable <overlay>      Enable Device Tree overlay
--dto-disable <overlay>     Disable Device Tree overlay
--dtp-enable <paramater>    Enable Device Tree parameter
--dtp-disable <paramater>   Disable Device Tree parameter
--cfg-enable <option>       Enable config.txt option
--cfg-disable <option>      Disable config.txt option
--rootfs-grow               Expand (grow) root filesystem on SD card
--bt-enable                 Enable bluetooth support for RPi3
--bt-disable                Disable bluetooth support for RPi3
--vc4-enable                Enable DRM VC4 V3D driver (Dispmanx)
--vc4-disable               Disable DRM VC4 V3D driver
--add-swap <size in MB>     Add and enable a swap file
--selinux <option>          Set SELinux mode (enforcing, permissive, disabled)
--bootsplash <option>       Plymouth graphical bootsplash (enable, disable)
--sys-info, -i              Show current system information
--version, -v               Output version information and exit
--help, -h                  Display this help and exit"
}


requires()
{

    if [ $UID != 0 ]; then
        echo "$NAME must be run as root user."
        exit 1
    fi

    if [[ $NO_DIALOG -eq 0 ]]; then
        # we require whiptail
        if [ ! -f /usr/bin/whiptail ]; then
            echo "$NAME requires whiptail. Please install"
            # offer to install here?
            exit 1
        fi
    fi
}


sys_info()
{
    # Hardware Info
    # get cpuinfo_cur_freq 1st otherwise CPU speed jumps & always shows max_freq
    CPU_CUR=$(($( </sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq)/1000))
    CPU_MAX=$(($( </sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq)/1000))
    CPU_MIN=$(($( </sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_min_freq)/1000))
    CPU_TEMP=$(($( </sys/class/thermal/thermal_zone0/temp)/1000))

    # OS Info
    DATE_TIME=$(date)
    SE_MODE=$(getenforce)
    KERN_VER=$(uname -r)
    MEM_FREE=$(awk '/MemFree/ { print $2 }' /proc/meminfo)
    MEM_AVLB=$(awk '/MemAvailable/ { print $2 }' /proc/meminfo)
    GPU_MEM=$(vcgencmd get_mem gpu |sed 's/[^0-9]*//g')
}


cmdline()
{
    CMD_ARG=$2

    # we don't want a dialog or questions
    NO_DIALOG=1

    dbg_chk

    requires

    cfg_check

    # Exclude some special DTO's for the moment
    for i in ${DTO_EXCLUDE[*]}; do
        if [[ "$CMD_ARG" == "$i" ]]; then
            msg "Enabling/disabling ${REF_NAMES[$CMD_ARG]} via cmdline is currently unsupported"
            exit 0
        fi
    done

    # weed out '-overlay' in dto names
    if [[ "$1" == "dto_enable" ]] || [[ "$1" == "dto_disable" ]]; then
        CMD_ARG=$(echo $CMD_ARG| sed 's/-overlay//')
    fi

    $1 $CMD_ARG ${3:-}
}


main()
{
    dbg_chk

    # check for script run requirements
    requires

    # check for & clean config.txt if necessary
    cfg_check

    # set WT dialog menu sizes
    dialog_size

    # start main menu
    menu_main

    # if needed, offer a reboot
    ask_reboot

    [ $DEBUG == 1 ] && exit 0 || clear; exit 0
}



###
# Main
###

DEBUG=0

case $1 in
    --dto-enable)
        cmdline dto_enable $2;;
    --dto-disable)
        cmdline dto_disable $2;;
    --dtp-enable)
        cmdline dtp_enable $2;;
    --dtp-disable)
        cmdline dtp_disable $2;;
    --cfg-enable)
        cmdline cfg_enable $2 ${3:-};;
    --cfg-disable)
        cmdline cfg_enable $2;;
    --rootfs-grow)
        touch /.rootfs-repartition && cmdline rootfs_grow;;
    --bt-enable)
        cmdline bt_enable;;
    --bt-disable)
        cmdline bt_disable;;
    --vc4-enable)
        DYN_DTO=false DTO_EXCLUDE=() cmdline dto_enable vc4-fkms-v3d
        vc4_enable vc4-fkms-v3d;;
    --vc4-disable)
        DYN_DTO=false DTO_EXCLUDE=() cmdline dto_disable vc4-fkms-v3d
        vc4_disable;;
    --add-swap)
        cmdline swap_add $2;;
    --selinux)
        cmdline selinux $2;;
    --bootsplash)
        cmdline bootsplash $2;;
    --sys-info|-i)
        NO_DIALOG=1 show_info;;
    --debug)
        DEBUG=1 main;;
    --log)
        DEBUG=1 LOG=1 main;;
    --help|-h)
        usage;;
    --version|-v)
        echo "$NAME - Version: $VERSION";;
    "")
        main;;
    *)
        echo "Unknown cmdline argument(s) $@";;
esac
